#!/bin/bash 

##### Information 
# Project name : Ai shuree
# Founder : Shuree  
# Worker : USPM [buya.psh@gmail.com]  
# Code writer : B.Sukhbat [1998bsuhe@gmail.com]  
# Used language : Linux bash script  

##### Setup up useful file and global variable 
# temp file 
tmp=/tmp/tmp_file_$$
# first level file name sort index
echo {a..z}{a..z}{a..z} > /tmp/lineindex 
# level abc parser user 26 alphabet
echo {a..z} > /tmp/abcindex 
# current directory
parser=$(cd $(dirname $0); pwd) 
# input file stored directory
uploads=$parser/uploads

##### Setup useful functions
source './functions'

##### Check input file is html or pdf 
if [ $(echo $1 | awk -F '.' '{print $NF}') != 'pdf' ] ;then 
	echo html file 
else 
    echo pdf 
    pdftotext -layout -nopgbrk "$uploads/$1" ${tmp}_coverted_data

    # remove empty line  
    cat ${tmp}_coverted_data | awk 'NF!=0' > ${tmp}_coverted_data_tmp

	# pdf_cleaning $tmp_coverted_data > $tmp_cleaned_data
    while read -r line; do echo $line; done < ${tmp}_coverted_data_tmp > ${tmp}_cleaned_data 

    # Setup file body range (now manually ==> change to auto)
    # Body first line number
    first_range=909
    # Body end line number 
    second_range=17858

    # Divide body   
    cat ${tmp}_cleaned_data | awk ''$first_range' < NR && NR < '$second_range'' > ${tmp}_cleaned_data-temp || exit 1
    mv ${tmp}_cleaned_data-temp ${tmp}_cleaned_data
fi

##### Make directory, store text file 
# make directory
mkdir $parser/result-0
# Copy cleaned data to tmp directory 
cp ${tmp}_cleaned_data $parser/result-0

##### Loop by parsing level 
# Setup level count 
count=0
for main_word in $(echo $2)
do
    # Create result storing directory 
	mkdir $parser/result-$(($count + 1))
    # Read all input files 
	files=$(find $parser/result-${count} -type f | sort)
    # Store level type into check variable 
    levelType=$(echo $main_word | awk -F "@" '{print $NF}')  
    # Store level key word into word variable 
    word=$(echo $main_word | awk -F '@' '{$NF="";print}' | sed 's/ /@/g')
    # Check level type 
    if [ $levelType == 'ug' ];then 
        # Loop by file 
        for file in $(echo $files)
        do 
            # Create directory for store this level result
            createDirectory "$count" "$file"
            # Search part
            cat $file | 
            grep -n ''$(seach_word_abc $(echo $word | sed 's/@/ /g'))'' | 
            sed 's/ /_/g' | 
            awk -F ':' '{print $2,$1,$1-1}' > ${tmp}-search-result-v1
            # Check first level or not
            setupFilenameIndex "$count" "${tmp}-search-result-v1" > ${tmp}-search-result-v2
            # Prepare search result
            prepareSearchResult "${tmp}-search-result-v2" "$file" > ${tmp}-search-result-v3
            # Divide file by search result
            divideFile "${tmp}-search-result-v3"
        done
    elif [ $levelType == 'abc' ];then 
        # Loop by all files
        for file in $(echo $files)
        do
            # Create directory for store this level result
            createDirectory "$count" "$file"
            # User input abc
            echo "$word" | 
            awk -F "@" '{print $1}' > ${tmp}-user-input-abc
            # Seperate bracket and alphabet
            cat ${tmp}-user-input-abc | 
            tr -d '()' > ${tmp}-end-abc
            # Find abc index 
            cat /tmp/abcindex | 
            sed 's/ /\n/g' |
            grep -n ''$(cat ${tmp}-end-abc)'' |
            awk -F ":" '{print $1}' > ${tmp}-end-abc-index
            # Setup alphabet index equal to 1. Searching start from a to user input alphabet
            abc_index_number=1
            # Loop : stop until search result in empty
            while true 
            do 
                # Search alphabet
                changer_search_abc=$(awk '{print $'$abc_index_number'}' < /tmp/abcindex)
                # Change user input to our first search word
                changed_search_abc=$(cat ${tmp}-user-input-abc | sed 's/[a-z]/a/g')
                # Enter search alphabe into input format
                search_abc=$(echo "$changed_search_abc" | sed 's/a/'$changer_search_abc'/g')
                # Find line number of search_abc
                cat $file |
                grep -n '^'$search_abc'\| '$search_abc' ' |
                awk -F ':' '{print "'$changer_search_abc'",$1,$1-1 }' > ${tmp}-result-line-number
                # Setup loop stop case variable 
                result=$(awk 'END{print NR}' < ${tmp}-result-line-number)
                # Check loop stop 
                if [[ $result == 0 ]];then 
                    # Prepare search result
                    prepareSearchResult "${tmp}-result-line-numbers" "$file" > ${tmp}-result-line-numbers-final
                    # Divide file by search result
                    divideFile "${tmp}-result-line-numbers-final"
                    break
                else 
                    cat ${tmp}-result-line-number >> ${tmp}-result-line-numbers
                fi 
                # Increase alphabet index
                abc_index_number=$(($abc_index_number + 1))
            done 
        done 
    elif [ $levelType == 'roman' ];then 
        search_roman_number=1
        for file in $(echo $files)
        do
            # Create directory for store this level result
            createDirectory "$count" "$file"
            # Search roman number from file and 
            #   if result is founded search next roman number 
            #   or result is not founded stop searching
            while true 
            do
                # Search part
                cat $file | 
                grep -nx ''$(echo $word | sed 's/@/ /g' | awk '{print $1}')" "$(int2roman $search_roman_number)'\|'$(echo $word | 
                sed 's/@/ /g' | 
                awk '{print $1}')" "$(int2roman $search_roman_number)"[A..Z]"' \|^\['$(echo $word | sed 's/@/ /g' | 
                awk '{print $1}')" "$(int2roman $search_roman_number)"[A..Z]"'' | 
                sed 's/ /_/g' > ${tmp}-search-result-v1 
                # Setup loop stop case variable 
                result=$(cat ${tmp}-search-result-v1 | awk 'END {print NR}')
                # Check loop stop
                if [[ $result == 0 ]];then 
                    cat ${tmp}-search-result-v1-collect | awk -F ':' '{print $NF,$1,$1-1}' > ${tmp}-search-result-v2
                    # Check first level or not
                    setupFilenameIndex "$count" "${tmp}-search-result-v2" > ${tmp}-search-result-v3
                    # Prepare search result
                    prepareSearchResult "${tmp}-search-result-v3" "$file" > ${tmp}-search-result-v4 
                    # Divide file by search result
                    divideFile "${tmp}-search-result-v4"
                    # Remove first search result 
                    rm -rf ${tmp}-search-result-v1-collect 
                    break
                else 
                    # Collect search result
                    cat ${tmp}-search-result-v1 >> ${tmp}-search-result-v1-collect
                fi 
                # increase roman number
                search_roman_number=$(($search_roman_number + 1))
            done 
        done 
    elif [ $levelType == 'range' ];then 
        sed_number=1
        for file in $(echo $files)
        do
            # Create directory for store this level result
            createDirectory "$count" "$file"
            # Search roman number from file and 
            #   if result is founded search next roman number 
            #   or result is not founded stop searching
            while true 
            do
                # Search part 
                # setup search word
                search_number=$(echo $word | awk -F '@' '{print $1}' | sed 's/1/'$sed_number'/g')
                # search word
                cat $file | grep -n '^'$sed_number'\.\|^'$sed_number'.\.\| '$sed_number'\. \| '$sed_number'.\. ' > ${tmp}-search-result-v1
                # Setup loop stop case variable 
                result=$(cat ${tmp}-search-result-v1 | awk 'END{print NR}')
                # Check loop stop
                if [ $result == 0 ];then
                    cat ${tmp}-search-result-v1-collect | awk -F ':' '{print $NF,$1,$1-1}' > ${tmp}-search-result-v2
                    # Check first level or not
                    setupFilenameIndex "$count" "${tmp}-search-result-v2" > ${tmp}-search-result-v3
                    # Prepare search result
                    prepareSearchResult "${tmp}-search-result-v3" "$file" > ${tmp}-search-result-v4 
                    # Divide file by search result
                    divideFile "${tmp}-search-result-v4"
                    # Remove first search result 
                    rm -rf ${tmp}-search-result-v1-collect 
                    break
                else 
                    # Collect search result
                    cat ${tmp}-search-result-v1 | awk '{print $0,":'$sed_number'"}' >> ${tmp}-search-result-v1-collect 
                fi 
                # increase range number
                sed_number=$(($sed_number + 1))
            done 
        done 
    elif [ $levelType == 'sub' ];then 
        for file in $(echo $files)
        do
            # Create directory for store this level result
            createDirectory "$count" "$file"
            # Setup every file sub number
            sed_number=1
            while true 
            do 
                # Search part 
                search_number=$(echo $word | awk -F "@" '{print $1}' | sed 's/1/'${sed_number}'/g' )
                cat $file | 
                grep -n '^'$search_number'\| '$search_number' ' | head -1 > ${tmp}-search-result-v1 
                result=$(cat ${tmp}-search-result-v1  | awk 'END{print NR}')
                if [ $result -eq 0 ];then 
                    # Check divide result or copy result
                    if [[ -s ${tmp}-search-result-v1-collect ]];then
                        cat ${tmp}-search-result-v1-collect | awk -F ':' '{print $NF,$1,$1-1}' > ${tmp}-search-result-v2
                        # Prepare search result
                        prepareSearchResult "${tmp}-search-result-v2" "$file" > ${tmp}-search-result-v3 
                        # Divide file by search result
                        divideFile "${tmp}-search-result-v3"
                    else 
                        # Directly copy result file
                        cat $file > $parser/result-$(($count + 1))/$(echo $file | awk -F "/" '{$1=""; $2=""; $3="";print $0}' | xargs echo | sed 's/ /\//g')/"@@@" 
                    fi 
                    rm -rf ${tmp}-search-result-v1-collect
                    break 
                else 
                    # Collect search result
                    cat ${tmp}-search-result-v1 | awk '{print $0":'$sed_number'"}' >> ${tmp}-search-result-v1-collect
                fi 
                # increase sub number
                sed_number=$(($sed_number + 1))
            done  
        done 
    elif [ $levelType == 'lroman' ];then
        # Write code here
    fi 
    # Increase level number
	count=$(($count + 1))
done 

##### Result convert to csv
for csv_row in $(find $(echo $parser/result* | sed 's/ /\n/g' | tail -1) -type f | sort) ; do echo $(echo $csv_row | awk -F '/' '{$1="";$2="";print $0}' | awk -F '<sep_index>' '{print $2}' | sed 's/ /\",\"/g' | sed 's/^/\"/g' | sed 's/$/\"/g')',"'$(cat $csv_row)'"'  ;done > $parser/final-$$.csv

##### Print result csv file name
echo '{ "output": "final-'$$'.csv"}'

##### Clean temp file and directory
rm -rf ${tmp}-*
# Remove comment in production version !!!
# rm -rf $parser/result-*